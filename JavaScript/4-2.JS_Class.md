# 1. Today I Learned

## JavaScript Class

---

## ES2015 Class

ES2015 이전까지는 비슷한 종류의 객체를 많이 만들어내기 위해 생성자를 사용해왔습니다.<br/>

```js
// 생성자
function Person({ name, age }) {
  this.name = name;
  this.age = age;
}
Person.prototype.introduce = function() {
  return `안녕하세요, 제 이름은 ${this.name}입니다.`;
};

const person = new Person({ name: "윤아준", age: 19 });
console.log(person.introduce()); // 안녕하세요, 제 이름은 윤아준입니다.
console.log(typeof Person); // function
console.log(typeof Person.prototype.constructor); // function
console.log(typeof Person.prototype.introduce); // function
console.log(person instanceof Person); // true
```

ES2015 에서 도입된 클래스는 생성자의 기능을 대체합니다.<br/>
class 표현식을 사용하면, 생성자와 같은 기능을 하는 함수를 훨씬 더 깔끔한 문법으로 정의할 수 있습니다.<br/>

```js
// 클래스
class Person {
  // 이전에서 사용하던 생성자 함수는 클래스 안에 `constructor`라는 이름으로 정의합니다.
  constructor({ name, age }) {
    this.name = name;
    this.age = age;
  }

  // 객체에서 메소드를 정의할 때 사용하던 문법을 그대로 사용하면, 메소드가 자동으로 `Person.prototype`에 저장됩니다.
  introduce() {
    return `안녕하세요, 제 이름은 ${this.name}입니다.`;
  }
}

const person = new Person({ name: "윤아준", age: 19 });
console.log(person.introduce()); // 안녕하세요, 제 이름은 윤아준입니다.
console.log(typeof Person); // function
console.log(typeof Person.prototype.constructor); // function
console.log(typeof Person.prototype.introduce); // function
console.log(person instanceof Person); // true
```

class 블록에서는 JavaScript 의 다른 곳에서는 사용되지 않는 별도의 문법으로 코드를 작성해야 합니다.<br/>
함수 혹은 객체의 내부에서 사용하는 문법과 혼동하지 않도록 주의가 필요합니다.<br/>

```js
// 클래스는 함수가 아닙니다!
class Person {
  console.log('hello');
}
// 에러: Unexpected token
```

```js
// 클래스는 객체가 아닙니다!
class Person {
  prop1: 1,
  prop2: 2
}
// 에러: Unexpected token
```

문법이 아니라 동작방식의 측면에서 보면, ES2015 이전의 생성자와 ES2015 의 클래스는 다음과 같은 차이점이 있습니다.<br/>

* 클래스는 함수로 호출될 수 없습니다.
* 클래스 선언은 let 과 const 처럼 블록 스코프에 선언되며, 호이스팅(hoisting)이 일어나지 않습니다.
* 클래스의 메소드 안에서 super 키워드를 사용할 수 있습니다.
  (super 란? 상속시 객체의 부모가 가지고 있는 함수를 호출할 수 있게 도와주는 키워드입니다.)

<br/><br/>

> 내일 남은 부분 수업을 듣고 조금 더 정리하여 회고할 예정입니다.
