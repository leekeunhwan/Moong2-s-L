<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>프로그래머스 문제 43번</title>
</head>

<body>
    <script>
        // 슈퍼 게임 개발자 오렐리는 큰 고민에 빠졌다.그녀가 만든 프랜즈 오천성이 대성공을 거뒀지만, 
        // 요즘 신규 사용자의 수가 급감한 것이다.원인은 신규 사용자와 기존 사용자 사이에 스테이지 차이가 너무 큰 것이 문제였다.

        // 이 문제를 어떻게 할까 고민 한 그녀는 동적으로 게임 시간을 늘려서 난이도를 조절하기로 했다.
        // 역시 슈퍼 개발자라 대부분의 로직은 쉽게 구현했지만, 실패율을 구하는 부분에서 위기에 빠지고 말았다.
        // 오렐리를 위해 실패율을 구하는 코드를 완성하라.

        // 실패율은 다음과 같이 정의한다.
        // 스테이지에 도달했으나 아직 클리어하지 못한 플레이어의 수 / 스테이지에 도달한 플레이어 수
        // 전체 스테이지의 개수 N, 게임을 이용하는 사용자가 현재 멈춰있는 스테이지의 번호가 담긴 배열 stages가 매개변수로 주어질 때, 
        // 실패율이 높은 스테이지부터 내림차순으로 스테이지의 번호가 담겨있는 배열을 return 하도록 solution 함수를 완성하라.

        // 제한사항
        // 스테이지의 개수 N은 1 이상 500 이하의 자연수이다.
        // stages의 길이는 1 이상 200, 000 이하이다.
        // stages에는 1 이상 N + 1 이하의 자연수가 담겨있다.
        // 각 자연수는 사용자가 현재 도전 중인 스테이지의 번호를 나타낸다.
        // 단, N + 1 은 마지막 스테이지(N 번째 스테이지) 까지 클리어 한 사용자를 나타낸다.
        // 만약 실패율이 같은 스테이지가 있다면 작은 번호의 스테이지가 먼저 오도록 하면 된다.
        // 스테이지에 도달한 유저가 없는 경우 해당 스테이지의 실패율은 0 으로 정의한다.

        // 입출력 예
        // N	stages	result
        // 5 [2, 1, 2, 6, 2, 4, 3, 3] [3, 4, 2, 1, 5]
        // 4 [4, 4, 4, 4, 4] [4, 1, 2, 3]

        // 입출력 예 설명
        // 입출력 예 #1
        // 1번 스테이지에는 총 8명의 사용자가 도전했으며, 이 중 1명의 사용자가 아직 클리어하지 못했다.
        // 따라서 1번 스테이지의 실패율은 다음과 같다.

        // 1 번 스테이지 실패율: 1 / 8
        // 2번 스테이지에는 총 7명의 사용자가 도전했으며, 이 중 3명의 사용자가 아직 클리어하지 못했다.
        // 따라서 2번 스테이지의 실패율은 다음과 같다.

        // 2 번 스테이지 실패율: 3 / 7
        // 마찬가지로 나머지 스테이지의 실패율은 다음과 같다.

        // 3 번 스테이지 실패율: 2 / 4
        // 4번 스테이지 실패율: 1 / 2
        // 5번 스테이지 실패율: 0 / 1
        // 각 스테이지의 번호를 실패율의 내림차순으로 정렬하면 다음과 같다.

        // [3, 4, 2, 1, 5]
        // 입출력 예 #2

        // 모든 사용자가 마지막 스테이지에 있으므로 4번 스테이지의 실패율은 1이며 
        // 나머지 스테이지의 실패율은 0이다.

        // [4, 1, 2, 3]

        function solution(N, stages) {
            // 답을 담을 배열
            let answer = [];
            // 스테이지 카운팅 및 무한루프 방지용 숫자형 변수 선언
            let stageCount = 1;
            // 스테이지의 갯수 모두 카운트 할때까지
            while (stageCount != N + 1) {
                // 실패횟수는 0
                let fail = 0;
                //  사용자가 현재 도전 중인 스테이지의 번호가 담긴 배열을 돌면서
                for (let i = 0; i < stages.length; i++) {
                    // 도전 중인 스테이지의 번호가 스테이지보다 작거나 같으면
                    if (stages[i] <= stageCount) {
                        // 실패
                        fail++;
                    }
                }
                // 해당 스테이지를 검사하고 나면
                // stage와 failPercent를 담은 객체를 정답으로 이동
                answer.push({
                    stage: stageCount,
                    failPercent: fail > 0 ?
                        fail / stages.length : 0
                })
                // 실패한 친구들은 이제 빠져야 하므로, 살아남은 친구들로 배열 갱신
                stages = stages.filter(item => item > stageCount)
                // 실패횟수 초기화
                fail = 0;
                // 스테이지 카운트 업
                stageCount++;
            }

            // 정답에 담아놓은 데이터를 가지고
            answer.sort(function (a, b) {
                // failPercent 기준 오름차순으로 정렬하되
                return a.failPercent > b.failPercent ? -1 :
                    a.failPercent < b.failPercent ? 1 :
                    // 둘다 같을 경우 스테이지가 낮은 요소가 앞으로 오도록 함.
                    a.failPercent === b.failPercent ? a.stage < b.stage ? -1 : 1 : 0;
            })
            // 정렬이 끝났으니 스테이지만 뽑아서 제출
            return answer.map(item => item.stage);
        }

        // 자려다 풀음..!
        // 말로 과정을 적고 코드로 옮기는 건 좋은데
        // 옮기는 방식이 너무 후져서 아까 2문제에서 시간 초과가 났었다.
        // 최대한 반복문 안쓰고 풀 수 있도록 사고하는 방식이 필요하다.
        // 예전에는 풀 엄두도 안났는데 그래도 이제는 쉽게 쉽게 되는 것 같다.
        // 조금만 더 힘내보자.
    </script>
</body>

</html>