<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>프로그래머스 문제 45번</title>
</head>

<body>
    <script>
        // 카카오톡에 뜬 네 번째 별!심심할 땐 ? 카카오톡 게임별~

        // 카카오톡 게임별의 하반기 신규 서비스로 다트 게임을 출시하기로 했다.
        // 다트 게임은 다트판에 다트를 세 차례 던져 그 점수의 합계로 실력을 겨루는 게임으로, 
        // 모두가 간단히 즐길 수 있다.
        // 갓 입사한 무지는 코딩 실력을 인정받아 게임의 핵심 부분인 점수 계산 로직을 맡게 되었다.
        // 다트 게임의 점수 계산 로직은 아래와 같다.

        // 다트 게임은 총 3 번의 기회로 구성된다.
        // 각 기회마다 얻을 수 있는 점수는 0 점에서 10 점까지이다.
        // 점수와 함께 Single(S), Double(D), Triple(T) 영역이 존재하고 
        // 각 영역 당첨 시 점수에서 1 제곱, 2 제곱, 3 제곱(점수1, 점수2, 점수3) 으로 계산된다.
        // 옵션으로 스타상( * ), 아차상(#) 이 존재하며 스타상( * ) 당첨 시 해당 점수와 바로 전에 얻은 점수를 각 2 배로 만든다.
        // 아차상(#) 당첨 시 해당 점수는 마이너스된다.
        // 스타상( * ) 은 첫 번째 기회에서도 나올 수 있다.
        // 이 경우 첫 번째 스타상( * ) 의 점수만 2 배가 된다.(예제 4 번 참고)
        // 스타상( * ) 의 효과는 다른 스타상( * ) 의 효과와 중첩될 수 있다.
        // 이 경우 중첩된 스타상( * ) 점수는 4 배가 된다.(예제 4 번 참고)
        // 스타상( * ) 의 효과는 아차상(#) 의 효과와 중첩될 수 있다.
        // 이 경우 중첩된 아차상(#) 의 점수는 - 2 배가 된다.(예제 5 번 참고)
        // Single(S), Double(D), Triple(T) 은 점수마다 하나씩 존재한다.
        // 스타상( * ), 아차상(#) 은 점수마다 둘 중 하나만 존재할 수 있으며, 존재하지 않을 수도 있다.
        // 0~10 의 정수와 문자 S, D, T, *, #로 구성된 문자열이 입력될 시 총점수를 반환하는 함수를 작성하라.

        function solution(dartResult) {
            // 각각 게임을 계산해서 담고 합을 구하기 위해 배열 선언
            let answerArr = [];
            // 각각의 게임을 나누기 위한 배열
            let splitGame = [];
            // 정규식 : 0-9,S,D,T,*,#를 포함하면 그룹화 아니면 패스
            const pattern = "(?:([0-9]+)([SDT])([*#]?))"
            // 3게임이니까 3번 패턴 곱해서 글자의 모든 패턴 검색
            const regex = new RegExp(pattern.repeat(3), "g");
            // 정규식대로 검색해서 1,10까지 자르기, 
            // 자르는 이유는 [0]은 일치하는 전체 문자열이고, 
            // 10이후로는 index, input의 정보가 있기에 필요한 부분만 쓰기 위해 자른다.
            const gameSlice = regex.exec(dartResult).slice(1, 10);
            // 각각의 게임마다 분리
            splitGame = [gameSlice.slice(0, 3), gameSlice.slice(3, 6), gameSlice.slice(6, 9)]

            // 게임을 분리한 배열을 돌면서, 즉 각각의 게임마다
            for (let i = 0; i < splitGame.length; i++) {
                // 보너스 계산 해주기
                // [1]이라고 직접적으로 한 이유는,
                // 3으로 나뉘는 명확한 기준이 있었기 떄문 (점수, 보너스, 효과)
                const bonus = splitGame[i][1] === 'S' ? 1 :
                    splitGame[i][1] === 'D' ? 2 :
                    splitGame[i][1] === 'T' ? 3 : '에러'
                // 정답 배열에 점수와 보너스를 제곱계산하여 넣어준다.
                answerArr.push(Math.pow(splitGame[i][0], bonus))
                // 만약 효과가 있을경우
                if (splitGame[i][2] !== '') {
                    // *일때 앞에 숫자가 있다면
                    if (splitGame[i][2] === '*' && answerArr[i - 1]) {
                        // 앞에 숫자도 2배
                        answerArr[i - 1] = answerArr[i - 1] * 2
                        // 지금 숫자도 2배
                        answerArr[i] = answerArr[i] * 2
                        // *일때 앞의 숫자가 없다면
                    } else if (splitGame[i][2] === '*') {
                        // 지금 숫자만 2배
                        answerArr[i] = answerArr[i] * 2
                        // #일때는
                    } else if (splitGame[i][2] === '#') {
                        // 지금 숫자 * -1
                        answerArr[i] = answerArr[i] * -1
                    }
                }
            }

            // 정답은 배열의 합을 더해주면 끝
            return answerArr.reduce((a, b) => a + b, 0);
        }

        // 초반에 정규식 안쓰고, 일일히 for문으로 나눠보려고 했는데,
        // 너무 복잡하기도 했고, 코드가 길기도 했고,
        // 무엇보다 채점하면 4문제가 틀려버려서 더 가지고
        // 케이스 계산을 해볼까 하다가 정규표현식으로 해봤다.
        // 역시 정규표현식으로 하니 틀렸던 것도 잘 통과하는게...
        // 가급적 문자열을 규칙에 맞게 나누거나 발리데이트를 해야하는 경우는 
        // 정규표현식을 쓰는게 좋을 것 같다...
        // 이후 계산은 워낙 쉽게 됬다.
        // 사서 고생하지말고, 머리를 쓰는걸로...ㅎㅎ
        // 좀 더 생각을 키워보고 쉽게 접근하되 구현은 보다 고민하는 걸로
        // 계속 풀어봐야겠다.
    </script>
</body>

</html>