<!DOCTYPE html>

<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>프로그래머스 문제 31번</title>
</head>

<body>
    <script>
        // 문제 설명
        // 1937년 Collatz란 사람에 의해 제기된 이 추측은, 입력된 수가 짝수라면 2로 나누고, 홀수라면 3을 곱하고 1을 더한 다음, 결과로 나온 수에 같은 작업을 1이 될 때까지 반복할 경우 모든 수가 1이 된다는 추측입니다. 예를 들어, 입력된 수가 6이라면 6→3→10→5→16→8→4→2→1 이 되어 총 8번 만에 1이 됩니다. 입력된 수가 몇 번 만에 1이 되는지 반환하는 함수, solution을 완성해 주세요. 단, 500번을 반복해도 1이 되지 않는다면 –1을 반환해 주세요.

        // 제한 사항
        // 입력된 수, num은 1 이상 8000000 미만인 정수입니다.
        // 입출력 예
        // n	result
        // 6	8
        // 16	4
        // 626332	-1
        // 입출력 예 설명
        // 입출력 예 #1
        // 문제의 설명과 같습니다.

        // 입출력 예 #2
        // 16 -> 8 -> 4 -> 2 -> 1 이되어 총 4번만에 1이 됩니다.

        // 입출력 예 #3
        // 626331은 500번을 시도해도 1이 되지 못하므로 -1을 리턴해야합니다.

        function solution(num) {
            // 정답을 담을 변수 선언
            let answer = 0;
            // 500번을 반복해봐서 1이 나오면 횟수인 i의 값을 정답으로 1이 안나오면 -1을 정답으로 하면 된다.
            for (let i = 0; i < 500; i++) {
                // num이 1이면
                if (num == 1) {
                    // 정답은 i
                    answer = i;
                    // 정답 출력
                    return answer;
                }
                // num이 홀수면 num은 홀수일때의 식을 짝수면 짝수일 때의 식을 실행한다.
                (num % 2) ? num = num * 3 + 1: num /= 2;
            }
            // 500번 다 돌아도 안나왔으므로 answer는 -1
            answer = -1;
            // 정답 출력
            return answer;
        }

        // 습관적으로 answer = i+1처럼 무의식중에 0부터 시작한다고 1을 붙이는 버릇이 있어서 애를 먹었다.
        // 반복문이 어떤 과정으로 어떻게 작동할 것인지 항상 생각하고 충분히 판단해보자!
    </script>
</body>

</html>