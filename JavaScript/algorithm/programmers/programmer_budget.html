<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>프로그래머스 문제 42번</title>
</head>

<body>
    <script>
        // 문제 설명
        // S사에서는 각 부서에 필요한 물품을 지원해 주기 위해 부서별로 물품을 구매하는데 필요한 금액을 조사했습니다.
        // 그러나, 전체 예산이 정해져 있기 때문에 모든 부서의 물품을 구매해 줄 수는 없습니다
        // 그래서 최대한 많은 부서의 물품을 구매해 줄 수 있도록 하려고 합니다.

        // 물품을 구매해 줄 때는 각 부서가 신청한 금액만큼을 모두 지원해 줘야 합니다.
        // 예를 들어 1, 000 원을 신청한 부서에는 정확히 1,000 원을 지원해야 하며, 
        // 1,000 원보다 적은 금액을 지원해 줄 수는 없습니다.

        // 부서별로 신청한 금액이 들어있는 배열 d와 예산 budget이 매개변수로 주어질 때, 
        // 최대 몇 개의 부서에 물품을 지원할 수 있는지
        // return 하도록 solution 함수를 완성해주세요.

        // 제한사항
        // d는 부서별로 신청한 금액이 들어있는 배열이며, 길이(전체 부서의 개수) 는 1 이상 100 이하입니다.
        // d의 각 원소는 부서별로 신청한 금액을 나타내며, 부서별 신청 금액은 1 이상 100,000 이하의 자연수입니다.
        // budget은 예산을 나타내며, 1 이상 10,000,000 이하의 자연수입니다.

        // 입출력 예
        // d budget result
        // [1, 3, 2, 5, 4] 9 3
        // [2, 2, 3, 3] 10 4

        // 입출력 예 설명
        // 입출력 예 #1
        // 각 부서에서 [1원, 3원, 2원, 5원, 4원]만큼의 금액을 신청했습니다.
        // 만약에, 1원, 2원, 4원을 신청한 부서의 물품을 구매해주면 예산 9원에서 7원이 소비되어 2원이 남습니다.
        // 항상 정확히 신청한 금액만큼 지원해 줘야 하므로 남은 2원으로 나머지 부서를 지원해 주지 않습니다.
        // 위 방법 외에 3개 부서를 지원해 줄 방법들은 다음과 같습니다.

        // 1원, 2원, 3원을 신청한 부서의 물품을 구매해주려면 6원이 필요합니다.
        // 1원, 2원, 5원을 신청한 부서의 물품을 구매해주려면 8원이 필요합니다.
        // 1원, 3원, 4원을 신청한 부서의 물품을 구매해주려면 8원이 필요합니다.
        // 1원, 3원, 5원을 신청한 부서의 물품을 구매해주려면 9원이 필요합니다.
        // 3개 부서보다 더 많은 부서의 물품을 구매해 줄 수는 없으므로 최대 3개 부서의 물품을 구매해 줄 수 있습니다.

        // 입출력 예 # 2
        // 모든 부서의 물품을 구매해주면 10 원이 됩니다.따라서 최대 4 개 부서의 물품을 구매해 줄 수 있습니다.

        function solution(d, budget) {
            // 접근 방식은 다음과 같다.
            // 한도를 넘어버리면 예산 초과이기 때문에
            // 한도를 안넘기는 선에서 최대한 더해준다.

            // 정답은 지원해줄 수 있는 부서의 수를 의미
            let answer = 0;
            // 예산이 넘는지 체크하기 위해 부서의 필요 예산을 더할 숫자타입의 변수 선언
            let sum = 0;
            // 쉽게 효율적으로 계산하기 위해 먼저
            // 예산을 요구하는 배열인 d를 오름차순으로 정렬한다.
            let sortD = d.sort(function (a, b) {
                return a - b
            })

            // 배열을 돌면서
            for (let i = 0; i < sortD.length; i++) {
                // 더했던 값과 부서의 요구액을 더한 것이 예산을 넘지않거나 딱 맞다면
                if (sum + sortD[i] <= budget) {
                    // 일단 초과는 아니니까 더해준다.
                    sum += sortD[i]
                    // 그리고 지원이 됬으므로 숫자 카운트 업
                    answer++
                } else {
                    // 굳이 초과했는데 for문 돌릴필요 없으니 break;
                    // 상상해보자. 배열의 크기가 엄척크면,
                    // 이런거 안해주면 불필요한 연산이 돈다.
                    break;
                }
            }

            // 정답 반환
            return answer;
        }

        // 문제만 읽으면 정말 어렵지 않은 건데,
        // 말뜻을 잘못 이해해서 처음 몇분은 혼자서 경우의 수를 구하는건가하고
        // 쇼를 했다. 문제를 잘 읽고 진짜 포인트가 무엇인지를 보자.
        // 개발자는 이과적인 사고를 갖고 있지만, 요구사항을 빠르고 정확하게 캐치해야 한다.
        // 문제를 풀지말고 3번정도 정독하고 요구사항을 먼저 정의하고 문제를 푸는 습관을 들이자.
        // break 같은건 깨알 아이디어였는데 언제부턴가 연산의 횟수를 생각하다보니
        // 조금씩 생각이 더 좋은 방법은 없을까 하고 생각하는 것 같다.
        // 고무적이다. 좀 더 공부하고 생각하고 자주 풀어보자.
    </script>
</body>

</html>