<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>프로그래머스 문제 37번</title>
  </head>
  <body>
    <script>
      // 프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다.각 기능은 진도가 100 % 일 때 서비스에 반영할 수 있습니다.

      // 또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다.

      // 먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요.

      // 제한 사항
      // 작업의 개수(progresses, speeds배열의 길이)는 100개 이하입니다.
      // 작업 진도는 100 미만의 자연수입니다.
      // 작업 속도는 100 이하의 자연수입니다.
      // 배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다.예를 들어 진도율이 95 % 인 작업의 개발 속도가 하루에 4 % 라면 배포는 2일 뒤에 이루어집니다.

      // 입출력 예
      // progresses	speeds	return
      // [93, 30, 55][1, 30, 5][2, 1]

      // 입출력 예 설명
      // 첫 번째 기능은 93 % 완료되어 있고 하루에 1 % 씩 작업이 가능하므로 7일간 작업 후 배포가 가능합니다.
      // 두 번째 기능은 30 % 가 완료되어 있고 하루에 30 % 씩 작업이 가능하므로 3일간 작업 후 배포가 가능합니다.하지만 이전 첫 번째 기능이 아직 완성된 상태가 아니기 때문에 첫 번째 기능이 배포되는 7일째 배포됩니다.
      // 세 번째 기능은 55 % 가 완료되어 있고 하루에 5 % 씩 작업이 가능하므로 9일간 작업 후 배포가 가능합니다.

      // 따라서 7일째에 2개의 기능, 9일째에 1개의 기능이 배포됩니다.

      function solution(progresses, speeds) {
        // 정답을 담는 배열
        let answer = [];

        // 개발이 언제 끝나는지 날짜를 담을 배열
        let dayArr = [];

        // 100프로가 완성이기에
        // 100에서 진행도를 뺴고, 나머지를 속도로 나눠주면 날짜가 나온다.
        // 하지만 위에서도 언급했듯이, 2.3일처럼 나머지가 있으면 올림을 하여 3일로 산정한다.
        // 그렇게 각각 계산해서 dayArr로 push하기
        for (let i = 0; i < progresses.length; i++) {
          const day = (100 - progresses[i]) / speeds[i];
          dayArr.push(Math.ceil(day));
        }

        // 각자 진행도에 따른 날짜가 나와서 비교를 해줘야한다.
        // 토너먼트와 비슷하게 대상의 숫자가 비교하는 숫자보다 크면
        // 카운트만 올리고 다음의 비교 숫자와 비교를 한다.
        // 하지만 비교하는 숫자가 대상의 숫자보다 큰 경우,
        // 대상의 숫자는 거기까지이고, 카운팅 된 것을 answer로 보내고,
        // 비교하는 숫자를 다시 대상으로 넣고 배열의 모든 요소가 비교될수있게 진행한다.

        // 처음 바로 떨어지면, 즉 개발이 먼저 종료되는 것이기에 배포할수 있음으로 이니셜 카운팅 밸류는 1
        let dayValue = 1;

        // 첫번째 숫자 떼어서 나오기
        // dayArr[0]으로 밸류만 가져올수 있지만 그럼 dayArr.shift()를 해줘야 하므로 한번에 퉁칠수있는 splice 사용
        let target = dayArr.splice(0, 1);

        // dayArr의 모든 요소를 비교할때까지
        while (dayArr.length) {
          // 대상의 숫자가 비교하는 숫자보다 크면
          if (target >= dayArr[0]) {
            // 카운팅 업
            dayValue++;

            // 만약 dayArr의 사이즈가 1이면 이번 비교가 마지막이란 의미이기에
            if (dayArr.length === 1) {
              // 정답으로 카운팅한거 보내주기
              answer.push(dayValue);
            }

            // 배열 앞의 요소 1개 삭제
            dayArr.splice(0, 1);

            // 만약에 비교하는 숫자가 대상의 숫자보다 크면
          } else {
            // 대상은 이제 그만이기에 카운팅한 거 보내기
            answer.push(dayValue);
            // 다시 카운팅 초기화
            dayValue = 1;

            // 만약 dayArr의 사이즈가 1이면 이번 비교가 마지막이란 의미이기에
            if (dayArr.length === 1) {
              // 정답으로 카운팅한거 보내주기
              answer.push(dayValue);
            }

            // 배열 앞의 요소 1개 삭제
            target = dayArr.splice(0, 1);
          }
        }

        // 정답 뱉어내기
        return answer;
      }

      /*
      
      실무하다가 간만에 풀어본건데 어렵다.
      나중에 이직할 때 큰일 안나려면 지금부터 조금씩 해두자
      일단 접근하는 생각은 나쁘지 않았지만, 비교하는 부분에서 시간이 되게 많이 걸렸고, 그릇된 판단도 많이 했다.
      다양한 자료구조들도 만들어보고, 문제 많이 풀어보고 다른사람 코드도 보고 해야겠다.
      한 2달정도만 빠짝 해놓자

    */
    </script>
  </body>
</html>
