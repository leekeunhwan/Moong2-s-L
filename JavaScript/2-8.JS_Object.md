# 1. Today I Learned

## JavaScript Object

---

## 객체

자바스크립트에서 객체는 단순히 ‘이름(key):값(value)’형태의 프로퍼티들을 저장하는 컨테이너로서,<br/>
컴퓨터 과학 분야에서 해시라는 자료구조와 상당히 유사합니다.<br/>
자바스크립트에서 기본타입은 하나의 값만을 가지는 데 비해, 참조 타입인 객체는 여러 개의 프로퍼티들을 포함할 수 있으며,<br/>
이러한 객체의 프로퍼티는 기본 타입의 값을 포함하거나, 다른 객체를 가리킬 수도 있습니다.<br/>
이러한 프로퍼티의 성질에 따라 객체의 프로퍼티는 함수로 포함할 수 있으며, 자바스크립트에서는 이러한 프로퍼티를 메서드라고 부릅니다.<br/>

<br/><br/>

## 객체 리터럴

객체 리터럴을 이용해서 객체를 생성할 수 있습니다.<br/>
중괄호 안에 직접 이름-값 쌍을 적어주면 됩니다.<br/>

```js
const moong2 = {
  name: "이근환",
  age: 29,
  gender: "male",
  email: "dlrmsghks7@gmail.com"
};
```

위의 moong2 라는 변수에 할당된 객체에는 4 개의 속성이 저장되었습니다.<br/>
위의 속성 이름은 영어로 되어있지만 한글을 사용할 수도 있습니다.<br/>
단, 한글을 사용할 경우 ''를 써서 문자열 표기를 적어줘야 합니다.<br/>
속성의 이름도 식별자처럼 허용되지 않는 문자를 사용할 수 없지만 사용할 경우 문자열 표기를 해줘야 합니다.<br/>
객체 리터럴을 이용해 속성을 지정할 때, 이미 정의된 변수의 이름을 그대로 속성으로 사용할 수도 있습니다.<br/>

```js
const name = "이근환";

const moong2 = {
  name: name,
  age: 29
};
```

위 코드를 아래처럼 줄여서 쓸 수도 있습니다.<br/>

```js
const name = "이근환";

const moong2 = {
  name,
  age: 29
};
```

또한 대괄호를 사용해서 다른 변수에 저장된 문자열을 그대로 속성의 이름으로 쓰는 것도 가능합니다.<br/>

```js
const propName = "age";

const moong2 = {
  [propName]: 29
};

moong2.age;
```

<br/><br/>

## 점 표기법, 대괄호 표기법

속성 접근자(property accessor)를 이용해 이미 생성된 객체의 속성을 지정해줄 수도 있습니다.<br/>

```js
const moong2 = {};

moong2.name = "이근환";
moong2.age = 29;
moong2.gender = "male";
moong2.computerLanguage = ["javascript", "java"];
```

객체 리터럴을 이용해 빈 객체를 생성한 후 점 표기법을 통해 속성을 갱신하였습니다.<br/>
그러나, JS 에서는 식별자로 허용되지 않는 문자가 들어간 속성 이름을 사용해야 하는 경우에 반드시 대괄호 표기법을 사용해야 합니다.<br/>

```js
moong2.['재밌게 본 영화'] = "lala land";
```

위와 같은 경우가 아니라면 주로 점 표기법을 많이 사용합니다.<br/>

<br/><br/>

## 객체 다루기

속성 접근자, delete 연산자, in 연산자를 통해 객체에 대한 정보를 읽고 쓸수 있습니다.<br/>

```js
const moong2 = {
  name: "이근환",
  age: 29,
  gender: "male"
};

// 속성 읽기
moong2.name; //  "이근환"
moong2.age; //  29

// 속성 쓰기 - 이전 속성에 있던 값이 갱신됩니다.
moong2.age = "마음만은 25세";

// 새 속성 추가하기
moong2.nickname = "뭉이";
moong2.favoriteGame = "Battle Ground";

// 속성 삭제하기
delete moong2.age;

// 속성이 객체에 있는지 확인하기 - 여부를 확인하여 있으면 true, 없으면 false 반환
"name" in moong2; //  true
"email" in moong2; //  false
```

<br/><br/>

## 메소드(Method)

객체의 속성값으로 함수를 지정할 수도 있습니다.<br/>

```js
const moong2 = {
    react = function () {
        return 'smile'
    }
};

moong2.react(); //  'smile'
```

이처럼 어떤 객체의 속성으로 접근해서 사용하는 함수를 메소드라고 합니다.<br/>
객체 리터럴 안에서 특별한 표기법을 사용해 메소드를 정의할 수 있습니다.<br/>

```js
const moong2 = {
  react() {
    return "smile";
  }
};

moong2.react(); //  'smile'
```

<br/><br/>

## this

다른 함수들과 달리 메소드라는 특별한 이름을 사용하는 이유는 메소드가 다른 함수들과 다르게 특별취급되기 때문입니다.<br/>
this 를 사용하면 메소드 호출 시에 해당 메소드를 갖고 있는 객체에 접근할 수 있습니다.<br/>

```js
const moong2 = {
  name: "이근환",
  age: 29,
  introduce() {
    return `안녕하세요 제 이름은 ${name}이에요! 나이는 ${age}살입니다.`;
  },
  recovery() {
    this.age--;
  }
};

moong2.introduce(); // '안녕하세요 제 이름은 이근환이에요! 나이는 29살입니다.'
moong2.recovery(); //  undefined
moong2.introduce(); // '안녕하세요 제 이름은 이근환이에요! 나이는 28살입니다.'
```

메소드를 사용하면, 데이터와, 그 데이터와 관련된 동작을 객체라는 하나의 단위로 묶어서 다룰 수 있습니다.<br/>
이 것이 함수대신 메소드를 사용하는 핵심적인 이유입니다.<br/>
다만 function 키워드를 통해 정의된 함수 내부의 this 키워드가 실제로 무엇을 가리킬 것인가는<br/>
메소드가 어떻게 정의되는가에 의해 결정되는 것이 아니라 어떻게 사용되는가에 의해 결정됩니다.<br/>

```js
function thischeck() {
  return `이 this는 ${this.name}함수를 가리킵니다.`;
}

const func1 = {
  name: "func1",
  thischeck
};

const func2 = {
  name: "func2",
  thischeck
};

func1.thischeck();
func2.thischeck();
```

이렇게 thischeck 라는 함수가 객체 외부에서 정의되었고, func1 과 func2 에서 재사용되었는데 불구하고 메소드가 잘 동작했습니다.<br/>
즉, 같은 함수임에도 어떤 객체의 메소드로 사용되었느냐에 따라 내부의 this 가 가리키는 객체가 달라질 수 있다는 것입니다.<br/>
다만, 화살표 함수는 this 키워드를 전혀 다르게 취급하기 때문에 위와 같은 방식으로는 메소드로 사용될 수 없습니다.<br/>
또한, function 키워드를 통해 정의된 메소드가 항상 위와 같은 방식으로 this 를 취급하는 것은 아닙니다.<br/>
특별한 방법을 통해 아예 this 를 우리가 원하는 객체로 바꿔버릴 수 있습니다.<br/>

```js
function favoriteFood() {
  console.log(`${this.name}님이 좋아하시는 음식은 ${this.menu}입니다.`);
}

const info = { name: "이근환", menu: "초밥" };
const favoriteFoodForMoong2 = favoriteFood.bind(info);

favoriteFoodForMoong2();
```

이렇게 우리가 원하는 값을 가리키게 만들려면 함수 객체의 `bind`, `call`, `apply` 메소드를 사용하면 됩니다.<br/>
함수 객체의 bind 메소드를 호출하면, 메소드의 인수로 넘겨준 값이 this 가 되는 새로운 함수를 반환합니다.<br/>
call 혹은 apply 메소드를 사용하면, 새로운 함수를 만들지 않고도 임시적으로 this 를 바꿔버릴 수 있습니다.<br/>
call 과 apply 는 인수를 넘겨주는 형식에 차이가 있을 뿐, 나머지 기능은 같습니다.<br/>

```js
function favoriteFood(menu) {
  console.log(`${this.name}님이 좋아하시는 음식은 ${menu}입니다.`);
}

const info = { name: "이근환" };

favoriteFood.call(info, "초밥");
favoriteFood.apply(info, ["떡볶이"]);
```

<br/><br/>

## 프로토 타입

JS 에서는 객체 간에 공유되어야 하는 속성과 메소드를 프로토타입이라는 기능을 이용해서 효율적으로 저장할 수 있습니다.<br/>
어떤 객체에 프로토타입을 지정하면, 프로토타입의 속성을 해당 객체에서 재사용할 수 있습니다.<br/>
객체의 프로토타입을 지정하는 방법에는 여러 가지가 있는데, 가장 쉬운 방법은 `Object.create` 함수를 이용하는 것입니다.<br/>

```js
const lunchMenuPrototype = {
  suggest: function() {
    return `오늘 점심으로 ${this.menu} 어떠신가요?`;
  }
};

const day1 = Object.create(lunchMenuPrototype);
day1.menu = "짜장면";

const day2 = Object.create(lunchMenuPrototype);
day2.menu = "회덮밥";

day1.suggest();
day2.suggest();

day1.suggest === day2.suggest;
```

이렇게 프로토타입 기능을 이용해 한 객체에서 다른 객체의 기능을 가져와 사용하는 것을 프로토타입 상속이라고 합니다.<br/>
위의 경우를 `lunchMenuPrototype은 day1의 프로토타입이다.` 혹은 `day1 객체는 lunchMenuPrototype 객체를 상속받았다`고 표현합니다.<br/>
프로토타입 상속은 다른 언어에서는 흔히 찾아볼 수 없는 JS 의 특징적인 기능입니다.<br/>

> 오늘은 여기까지 내일 이어서 공부하겠습니다.

<br/><br/>

# 2. Today I Found Out

```
객체에 대해서 너무 쉽게만 알고 있었는데 자세히 공부를 하니 몰랐던 부분이 있어서
흥미롭게 살펴볼 수 있었습니다. 프로토타입에 대해서는 자바스크립트 관련 서적을 볼 때
굉장히 어렵게 느껴져서 잘 이해하지 못한채 넘어갔는데 오늘 승하쌤의
hellojavascriptworld를 통해서 설명을 보고 스스로 예시를 들어보니
이해를 할 수 있었습니다. 수업시간에 강의를 통해서 이제 이해했던 것을
확인하고 복습을 하면 충분히 제 것으로 만들 수 있을 것 같습니다.
```

<br/><br/>

# 3. refer

> https://helloworldjavascript.net/pages/180-object.html?q=

> http://insanehong.kr/post/javascript-object/

> https://developer.mozilla.org/ko/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript

> https://wayhome25.github.io/javascript/2017/02/19/js-oop-2/
