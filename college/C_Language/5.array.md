# C 프로그래밍 (5강 - 2020.03.31)

## 배열의 개념

---

`배열이란?`

- 동일한 자료 유형의 여러 변수들을 일괄적으로 선언하여 사용하는 자료 구조

<br/>

`배열의 용도`

- computer program에서 대량의 데이터에 대하여 동일 또는 유사한 연산을 반복적으로 수행하는 경우 사용
- 배열을 사용하면 유형이 같은 여러 개의 데이터에 대한 선언 및 처리가 용이
- 반복문을 사용하면 해당 데이터들에 대한 반복적인 연산을 효과적으로 처리

<br/>

`배열의 선언`

```c++
자료형 | 배열 이름 [배열 크기 (첨자, index라고 부름)];
int score[3];
// 숫자가 3개 들어가는 배열 score
```

<br/>

`배열의 원소 (array element)`

- 배열을 구성하는 각 원소는 동일한 데이터 유형(data type)을 가짐
- 이들 각 원소는 배열의 이름과 첨자(또는 index)로 참조

<br/>

`배열의 크기와 첨자`

- 배열의 원소는 첨자(index)를 사용하여 참조
- 배열의 첫 번째 원소는 항상 첨자가 0이며, 차례로 1씩 증가
  - 배열 첨자는 유효한 값의 범위를 벗어나는 경우 문제발생
  - 항상 배열 첨자의 사용에 주의
  - 첨자 범위: 0 ~ size-1

<br/>

`배열의 Memory 할당`

```c++
자료형 | 배열 이름 [배열 크기 (첨자, index라고 부름)];
int score[3];
// 숫자가 3개 들어가는 배열 score
```

- 배열 이름 score로 정수(int) 형의 저장 공간이 메모리에 연속적으로 할당됨
- 배열의 모든 원소는 동일한 자료형
- 배열의 크기는 원소의 수를 말하며, 위 경우는 3
- 배열의 각 원소를 참조하기 위한 수를 첨자(index)라고 함
- 첫 원소의 첨자는 반드시 0
- 두 번째 원소의 첨자는 1
- 마지막 원소의 첨자는 size-1
- 32bit

<br/>

`배열의 초기화`

- 할당 문을 통한 초기화 : 변수 선언 후 각 원소에 값을 초기화 해줌

```c++
#include<stdio.h>

void main() {
    int score[3], i;
    score[0] = 80;
    score[1] = 75;
    score[2] = 98;
    for (i=0; i<3; i++)
      printf("%d", score[i]);
}
```

- 선언 문을 통한 초기화 : 변수 선언 시 값을 초기화 해줌

```c++
#include<stdio.h>

void main() {
    int score[3] = {80, 75, 98}, i;
    for (i=0; i<3; i++)
      printf("%d", score[i]);
}
```

- 배열 원소의 수보다 초기화 값이 작으면 남은 기억 공간은 자동으로 0으로 초기화 됨

```c++
#include<stdio.h>

void main() {
    int score[3] = {80, 75}, i;
    for (i=0; i<3; i++)
      printf("%d", score[i]);
      // 80, 75, 0
}
```

- 배열을 선언할 때 초기화를 하면 배열 원소의 개수는 명시하지 않아도 됨

```c++
#include<stdio.h>

void main() {
    int score[] = {80, 75}, i;
    // 배열에 할당되는 수만큼 원소의 개수가 자동으로 결정됨
    for (i=0; i<3; i++)
      printf("%d", score[i]);
      // 80, 75
}
```

<br/>

`배열과 반복문`

- 배열 원소는 다른 변수와 동일하게 사용

  - `변수이름[첨자]` => 하나의 변수를 의미

- 배열과 반복문의 활용

  - 반복문의 index i를 배열의 첨자로 사용
  - 주의할 점: 배열의 첨자는 0부터 시작

<br/>

```c++
// 3x2 크기의 2차원 배열 선언과 구조
#include<stdio.h>

void main() {
    int score[3][2] = {{75, 40}, {54, 23}, {99, 12}}
    // 아래와 같음
    // int score[3][2];
    // score[0][0] = 75;
    // score[0][1] = 40;
    // score[1][0] = 54;
    // score[1][1] = 23;
    // score[2][0] = 99;
    // score[2][1] = 12;
}
```

<br/>

`배열 사용시 주의사항`

- 정해진 범위 바깥의 index를 사용하여 생기는 문제를 예측할 수 없음

- C 언어의 compiler는 경계 값 검사를 하지 않음

  - `int score[5];` 선언 후 `score[5] = 10;`을 하는 경우
  - compile 과정에서는 오류로 나타나지 않음
  - 실행하면 score 배열이 아닌 다른 memory 장소에 10이라는 값을 저장함으로써 비정상적인 결과를 초래

- index(배열의 첨자)는 반드시 0부터 시작

- 선언할 때를 제외하고는 배열 전체에 값을 대입할 수 없음

  - `int score[3]` // O
  - `score = {1,2,3};` // X

- 2차원 배열을 초기화할 때는 두 번째 차원의 크기를 생략할 수 없음

  - `int score[][] = {{1,1}, {2,2}}` // X
  - `int score[][2] = {{1,1}, {2,2}}` // O

<br/>

### 문자열

- 문자열은 문자의 배열을 의미
- 상수로서의 문자열은 일련의 문자들 앞 뒤로 인용부호 ""로 둘러싸서 표기
- 문자배열의 선언은 자료 형을 숫자 배열의 int 대신 char로 변경하여 아래와 같이 선언
  - `int score[3];` // 숫자 배열
  - `char score[3];` // 문자 배열

<br/>

`문자열의 구성`

- 항상 null 문자(₩0)가 문자열의 마지막에 위치

  - 만일 null 문자가 없는 경우 정상적인 문자열이 아님

- 따라서 끝에 null 문자를 포함시키기 위해서는 문자열을 저장하는 배열의 크기는<br/>
  저장되는 문자의 개수보다 1이 커야 함<br/>

<br/>

`문자열 vs 숫자열`

- 숫자열에서는 숫자를 낱개로 각각 읽어서 처리

- 반면에 문자열에서는 문자들을 한꺼번에 입력, 처리, 출력하는 것이 일반적

- 예외적으로 한 개 씩 처리되는 예

  - 'Y'/'N'과 같이 한 문자로 입력 받는 경우
  - 소문자를 대문자로 변경하는 경우

- 입, 출력 문에서 형식 지정자로 %c 대신 %s(string의 약자)를 사용

<br/>

`Memory 상의 문자열`

- 한글은 한 글자가 2 byte에 들어감
- 한글과 영문 모두 유효 값 뒤에 문자열 끝 문자인 ₩0이 있음을 알 수 있음
- 실제로 memory 상에서 'j'의 자리에는 0x4a가, 'o'의 자리에는 0x6f가 들어있음

<br/>

`두 개의 문자열을 입력받아 하나의 문자열로 합치는 프로그램을 작성하시오`<br/>
(예 : 첫 번째 문자열이 'kim', 두 번째 문자열이 'Lee'라면 'KimLee'로 합침)<br/>

```c++
#include<stdio.h>

void main() {
    char str1[10], str2[10], str3[20];
    scanf("%s", str1);
    scanf("%s", str2);
    int i, j;
    for (i=0; i<10 && str1[i] != 0; i++) str3[i] = str1[i]
    for (j=0; j<10 && str2[j] != 0; j++, i++) str3[i] = str1[j];
    str3[i] = 0;
    printf("%s + $s = $s\n", str1, str2, str3);
}
```

<br/>

`문자열의 주의사항`

- 배열의 마지막에 널 문자가 들어가게 됨

  - `char ename[8] = "john";` // john₩0

- 문자열은 printf 또는 puts를 통해서 출력, scanf 또는 gets를 통해 입력

  - puts와 gets는 문자열에 특화되므로 타입을 명시하지 않아도 문자열로 이해함 ("%s" 같은거 안넣어도 됨)

- 배열과 마찬가지로 선언 후 문자열로 초기화할 수 없음

- 문자열을 비교할 때는 == 연산자를 사용하는 것이 아니라 strcmp()를 사용

<br/>

`scanf()의 매개변수`

- scanf("%s", &str)에서 str은 값을 되돌려 받을 변수
- 이렇게 값을 되돌려 받기 위해서는 변수의 값이 아니라 변수의 주소를 매개변수로 주어야 함
- 따라서 &str를 함수의 매개변수로 넣은 것
- 그러나 str과 같은 string은 그 자체가 첫 번째 항목의 주소<br/>
  (즉, &str[0])와 같으므로 str을 그대로 함수의 매개변수로 넣어도 됨<br/>

<br/>

`scanf()와 gets()의 차이`

- scanf() 함수는 이어져 있는 문자열(즉, 중간에 blank가 없는 문자열)을 입력 받음

  - scanf("%s", "Let's Change the world"); // str: "Let's"

- 반면에 gets() 함수는 중간에 blank가 있더라도 한 줄 모두를 입력 받음

  - gets("%s", "Let's Change the world"); // str: "Let's Change the world"

<br/>

`2차원 문자열`

`1차원 문자열의 선언` - `char name1[9]`
`2차원 문자열의 선언` - `char name2[3][9]` // 3개의 이름이 들어가는데 10글자

<br/>

`2차원 문자열 반복처리`

- 1차원 문자열은 여러 개라도 반복 문 없이 처리해야 하지만,<br/>
  2차원이 되면 1차원이 다시 여러개 있으므로 반복 문으로 처리 가능<br/>

- 입출력 문에서 변수에 첨자를 넣으면 반복 문으로 변경 가능

<br/>

`2차원 문자열 초기화`

- 2차원 문자열을 초기화하려면 1차원에서 사용하는 단위 문자열을 ','로 구분하여 복수 개 나열
- 전체를 block으로 묶어주면 순서에 맞추어 초기화됨

<br/>

```c++
#include<stdio.h>

void main() {
    char name[2][9] = {"리정혁","세리"}
    int i;
    for (i=0; i<2; i++) {
        printf("이름은 %s입니다.₩n", names[i]);
    }
}
```

<br/>

`영어 단어를 입력 받아 대문자를 소문자로 바꾸어 출력하는 program`

```js
function toLowerCaseStr(str) {
  str = str.toString();
  return str.toLowerCase();
}
```

자바스크립트는 이랬지만...<br/>
C는 아래처럼..<br/>

```c++
#include<stdio.h>

void main() {
    char word[30];
    int i;

    scanf("%s", word);
    for (i=0; word[i] && i < 30; i++)
        if ("A" <= word[i] && word[i] <= "Z")
            word[i] = word[i] - "A" + "a";
    printf("%s₩n", word);
}
```

<br/>
