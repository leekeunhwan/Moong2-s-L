# 컴퓨터 개론 (1강 - 2020.03.13)

## 컴퓨터 정보의 표현

---

### 정보의 표현과 저장

`컴퓨터 정보`

- `2진수 비트 (0,1)`들로 표현된 프로그램 코드와 데이터
- 사용 가능한 2진수 조합 = Math.pow(2, n)
- 비트 수가 증가하면, 정보의 양과 저장해야 할 데이터의 양 증가
- 0은 열린 스위치(Off, false)로, 1은 닫힌 스위치(On, true)로 표현 가능

<br>

`프로그램 코드` -> 저급언어와 고급언어로 나뉨<br>
(컴퓨터에 친화적이면 저급언어, 사람에 친화적이면 고급언어)<br>

- 기계어

  - 기계 코드 (Machine Code)
  - 컴퓨터 하드웨어 부품들이 이해할 수 있는 언어
  - 2진 비트로 구성

<br>

- 어셈블리 언어 (기계어와 우리가 쓰는 것의 사이..)<br>
  ADD, MUL, SUB 과 같은 걸로 사람이 알수 있게 되어있지만 이해가 매우 잘되지 않음<br>

  - 고급 언어와 기계어 사이의 중간 언어
  - 어셈블러 (Assembler)로 번역시, 기계어와 일대일 대응
  - 구분하면 저급언어에 가까움...

<br>

- 고급 언어 (우리가 쓰는 것들..)

  - 영문자, 숫자로 구성되어 사람이 이해하기 쉬운 언어
  - C, C++, PASCAL, FORTRAN, COBOL 등...
  - 컴파일러(compiler : 언어번역기)를 이용하여 기계어(101001...)로 번역

<br>

`컴파일러의 역활`

- 컴파일러가 없으면 사용자가 1011 이런식으로 기계어로 써주지 않으면 이해 안됨
- 컴파일러는 사람이 명령하고자 하는 것을 컴퓨터의 언어로 바꿔주는 번역기, 통역의 역할을 한다.

<br>

`고급 언어로 작성된 Z = X + Y의 컴퓨터 인식`

- LOAD A, X : 기억장치 X번지의 내용을 읽어서 레지스터 (임시 저장장소) A에 적재 (LOAD)
- ADD A, Y : 기억장치 Y번지 내용을 읽어서, 레지스터 A에 적재된 값과 더하고, 결과를 다시 A에 적재
- STOR Z, A : 그 값을 기억장치 Z 번지에 저장 (Store)

```

고급 언어 프로그램 => 어셈블리 프로그램 => 기계어 프로그램

[ Z = X + Y ] => [ LOAD A, X ] => [ 00100101 ]
                 [ ADD  A, Y ]    [ 10000110 ]
                 [ STOR Z, A ]    [ 01000111 ]

```

<br>

`컴파일러 (Compiler)와 어셈블러 (Assembler)`

- 컴파일러

  - 고급 언어 프로그램을 기계어 프로그램으로 번역
  - C언어 -> 컴파일러 -> 기계어

- 어셈블러 (인터프리터)
  - 어셈블리 프로그램을 기계어 프로그램으로 번역
  - 니모닉스 (Mnemonics)
    - 어셈블리 명령어가 지정하는 연산을 가리키는 알파벳 기호
    - 'LOAD', 'ADD', 'STOR' 등...
  - 어셈블리어 프로그램 -> 어셈블러(DB) -> 기계어, 로더 위한 정보들

<br>

| 분류       | 특징                                                                                                                                     |
| ---------- | ---------------------------------------------------------------------------------------------------------------------------------------- |
| 컴파일러   | \* 고급 언어로 작성한 원시프로그램을 기계어로 번역하여 목적프로그램으로 생성하는 프로그램<br> \* 각종 고급 언어마다 고유의 컴파일러 존재 |
| 인터프리터 | \* 원시 프로그램을 구성하는 각각의 명령문을 한 줄씩 변환시키면서 즉시 시행하는 PGM BASIC, LISP, APL 등의 언어                            |
| 어셈블러   | \* 어셈블리어로 작성한 프로그램을 기계어로 번역                                                                                          |

<br>

### 진법 변환

`컴퓨터에서 정보 표현`

`비트 (Bit) -> 바이트 (1Byte = 8bit) -> 워드 (Word)`

- 비트 (Bit) : 데이터표현 최소단위

  - 2진수에서 데이터를 표현하는 단위
  - 컴퓨터에서는 데이터 1비트를 기본으로 0,1 두개의 숫자를 표시하는 2진법을 사용
  - 2진수의 조합은 Math.pow(2, n)만큼의 조합을 가질 수 있음 (n: 비트의 수)

<br>

- 바이트 (Byte) : 정보표현의 최소단위

  - 정보처리를 위해 사용되는 비트의 집합
  - 8Bit를 1Byte로 규정함

<br>

- 워드 (Word) : 컴퓨터가 한 번에 처리할 수 있는 데이터의 양

  - 컴퓨터 종류에 따라 구성됨 (2바이트, 4바이트 등..)
  - 2비트 (4바이트)가 가장 많이 쓰임

```
HDD(SSD) => RAM => CPU

HDD에 저장된 데이터를 RAM으로 옮겨서 CPU에서 연산을 처리하여
RAM이 기억하고 있다가 HDD에 저장하는데, 데이터가 버스를 통해
옮겨다니는 것을 32bit가 하느냐 64bit가 하느냐에 따라
작업 속도 및 처리량이 달라지게 된다.

예전에는 32Bit였지만, 근래에는 64Bit로 되면서
보다 처리속도 및 처리량이 좋아졌다.

32bit보다 64bit가 2배 빨라요?
-> 한번에 데이터 처리하는 양이 2배 빨리지니,
   2^n(n은 처리횟수)배 만큼 빨라질겁니다..
```

<br>

- 저장 용량의 기본 단위<br/>
  `킬로 => 메가 => 기가 => 테라 => 페타 => 엑사 => 제타 => 요타`<br/>

<br/>

| 구분 | K    | M    | G    | T    | P    | E    | Z    | Y    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 단위 | 킬로 | 메가 | 기가 | 테라 | 페타 | 엑사 | 제타 | 요타 |
| 환산 | 2^10 | 2^20 | 2^30 | 2^40 | 2^50 | 2^60 | 2^70 | 2^80 |

<br>

`진법에 따른 수의 변환`

1. 10진수

   - 0~9의 10가지 수를 한 자리(Digit)의 기본단위로 사용

   - 10진수

     - 각 자리는 오른쪽부터 1(10^0)자리, 10(10^1)자리, 100(10^2)자리 순

   - N진수

     - 각 자릿수는 0에서 N-1까지의 정수를 이용함
     - 오른쪽부터 n번째 자리의 크기는 N^n-1

   - 10진수를 2진수로 표현 하기 위해서는 2로 계속 나누면 된다.
   - 10진수를 8진수로 표현 하기 위해서는 8로 계속 나누면 된다.

<br/>

2. 2진수

   - 0과 1의 2가지 표현으로 각 자릿수를 표시
   - 오른쪽부터 2^0, 2^1, 2^2... 지수 증가
   - 2진수를 10진수로 바꾸려면 2 \* 1, 2 \* 2, 2 \* 4...처럼 각각의 자리 숫자를 곱한후 더해주면 된다.

<br/>

3. 8진수

   - 0부터 7까지의 8가지의 수를 이용하여 숫자를 표시
   - 8진수를 10진수로 바꾸려면 8 \* 1, 8 \* 2, 8 \* 4...처럼 각각의 자리 숫자를 곱한후 더해주면 된다.

<br/>

4. 16진수

   - 0에서 9까지 그리고 A에서 F까지 총 16개의 숫자나 문자를 사용하여 표시

<br/>

`컴퓨터에서 음수 표현 방법`

- 보수 : 컴퓨터에서 음의 정수를 표현하기 위해서 존재한다. (CPU에는 가산기(덧셈)민 존재하기 때문)
- 2의 보수 : 1의 보수에 1을 더하는 방법
- 1의 보수 : 주어진 이진수의 비트를 각각 0은 1로, 1은 0으로 변환하는 방법
- 부호와 절대치 : 양수 표현에 대하여 부호 비트의 값만 0을 1로 바꾸는 방법

<br/>

| 10진법 | 2진법 | 8진법 | 16진법 |
| ------ | ----- | ----- | ------ |
| 0      | 0000  | 0     | 0      |
| 1      | 0001  | 1     | 1      |
| 2      | 0010  | 2     | 2      |
| 3      | 0011  | 3     | 3      |
| 4      | 0100  | 4     | 4      |
| 5      | 0101  | 5     | 5      |
| 6      | 0110  | 6     | 6      |
| 7      | 0111  | 7     | 7      |
| 8      | 1000  | 10    | 8      |
| 9      | 1001  | 11    | 9      |
| 10     | 1010  | 12    | A      |
| 11     | 1011  | 13    | B      |
| 12     | 1100  | 14    | C      |
| 13     | 1101  | 15    | D      |
| 14     | 1110  | 16    | E      |
| 15     | 1111  | 17    | F      |

<br/>

### 보수의 개념

`보수란?` : 컴퓨터에서 음수를 표현할 때 사용

<br/>

- 부호화 절대치 : 첫 비트는 부호비트로, 음수일 때 '1'임
- 부호화 1의 보수 : 부호비트는 고정하고 각 자리 값을 바꿈 (0은 1, 1은 0)
- 부호화 2의 보수 : 1의 보수에서 마지막 자리에 1을 더함

```
10진수 -14를 2Bit로 표현해보세요

1110 -> 14

부호화 절대치 : 10001110 (첫 비트는 부호비트로 음수일 때 '1'임)
부호화 1의 보수 : 11110001 (부호비트는 고정하고, 각 자리 값을 바꿈)
부호화 2의 보수 : 11110010 (마지막 자리에 1을 더함)
```

<br/>

`r진법에서 (r-1)의 보수`

A라는 수에 B라는 수를 더해서 각 자리마다 자리올림이 발생하고<br/>
해당 자리는 0이 될 때, B는 A의 보수가 된다.<br/>

```
10진수 237에 대한 9의 보수를 B라고 가정할 때, B의 값은?

237 + B = 999
-> 237 + B = 1000 -1
-> B = 1000 - 1 - 237 = 732
```

<br/>

`부호가 없는 2진수의 뺄셈 연산에서 보수의 활용`

- 컴퓨터에서 뺄셈 연산은 보수를 이용하는 것이 효율적
- [ 8(피감수: 빼어지는 수) - 6(감수: 빼는 수) = 2 ]의 뺄셈 연산으로 보수의 활용
- 6을 9의 보수로 표현 : (10 - 1) - 6 = 3
- 6을 10의 보수로 표현 : 3 + 1 = 4
- 8 + 4 = 12

> 보수계산 확실하게 알아두기

<br/>

### 데이터의 2진수 표현

`데이터의 표현 방법 - 일반적인 디지털 장치에서 데이터의 표현`

- 2진수로 양의 정수, 음의 정수, 소수를 표현
- 2진수는 0, 1, 부호 및 소수점의 기호를 이용하여 수를 표현

<br/>

`소수의 표현`

`고정소수점(Fixed-point) 표현`

- 소수가 고정된 소수점을 통해서 구분하여 표현된 방식임
- 표현 범위의 한계가 있어 아주 큰 값과 매우 작은 값을 표현하는 것이 불가능함
- 예 : (17.60)`[10]`

<br/>

`부동소수점 표현`

- B는 기수(Base), E는 지수(Exponent)를 나타냄
- 지수를 사용해 소수점의 위치를 이동하여 수의 표현 범위를 확대함
- 예1, (176,000) = 1.76 \* Math.pow(10, 5)
- 예2, (0.000176) = 1.76 \* Math.pow(10, -4)

<br/>

### 문자 데이터의 표현

`문자 표현 방법`

`영숫자 코드 (Alphanumeric Code)`

- 컴퓨터에 사용되는 영문자와 숫자, 특수문자의 데이터를 0과 1의 조합으로 구성된 코드로 표현

<br/>

`표준 BCD 코드 (Binary Coded Decimal)`

- 이진화 십진 코드
- 기본적으로 6비트의 길이를 갖는 코드지만, 좀 더 효율적으로 사용하기 위해서
  존(zone)비트와 숫자(digit)비트로 분리하고 이를 조합하여 코드 생성

<br/>

`ASCII 코드`

- 미국 국립 표준협회
- 7비트와 패리티 비트가 추가된 두 종류의 8비트의 길이를 갖는 코드

<br/>

`2진수와 BCD 코드의 차이점`

| 2진수                         | BCD 코드                                                                                                                                                      |
| ----------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| \* 각 자리마다 무게 값이 있음 | \* 10진수 한자리를 4비트로 구성된 2진수로 표현함<br/> \* 4개의 비트 사용시 0000~1111가지 16개 표현이 가능하나, 10개만 사용하고, 1010~1111까지는 사용하지 않음 |

<br/>

`패리티 검사 코드 : 단순한 오류 검출 코드`

- 데이터는 전송 중에 변경될 수 있어 신뢰성 있는 통신을 위해 오류들은 검출, 정정되어야 하는데<br/>
  오류 검출에서 가장 널리 사용하는 코드<br/>

- 단일 - 비트 오류

- `00001010(Recived) <= 00000010(Sent)`

<br/>

`패리티 비트`

- 중복 비트로 데이터 단위에 덧붙임
- 패리티 비트를 포함한 데이터 단위 내의 1의 전체 갯수가
  짝수 (또는 홀수)가 되도록 함

<br/>

| 짝수 패리티(Even parity)                             | 홀수 패리티(Odd parity)                              |
| ---------------------------------------------------- | ---------------------------------------------------- |
| \* 1의 전체 개수가 짝수가 되도록 함<br/> \* '0' 추가 | \* 1의 전체 개수가 홀수가 되도록 함<br/> \* '1' 추가 |

<br/>

`해밍 코드 : 오류 검출 및 정정 코드`

- 오류를 스스로 검출하여 교정이 가능한 코드
- 1 Bit의 오류만 교정이 가능
- 데이터 비트 외에 여러 개의 교정을 위한 잉여 비트가 요구
- 1,2,4,8,16,...,2^n 번째 비트는 오류 검출을 위한 패리티 비트
- 자릿수 마다 삽입되며 앞에 있는 1의 갯수를 파악하여 홀수면 1, 짝수면 0이 들어감

<br/>
